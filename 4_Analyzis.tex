\chapter{Analysis rules}\label{chapter:analysis}

% Intuition how scenario analysis works, then formal inference rules are presented
% Begin with four rules to translate the core of each recurisve UDF
% Extending scope to whole queries
% Adding CTEs
% Post processing

This chapter gives detailed insights into the way a given query is sliced into its different evaluation-scenarios by presenting inference rules. I will illustrate the basic idea of each inference rule before formalizing it.

I begin by presenting a set of four rules which are required to translate most basic \CASE-expressions. The nonrecursive rules \RREC and \RBASE handle the basecases if the SQL-fragment is directly a recursive call or does not contain any call at all. Disassembling \CASE-expressions is the true core of the translation process as it is the origin of any scenario. Each \WHEN-\THEN~branch is processed step by step by the \RWHEN-rule and eventually the \ELSE-branch by the \RELSE-rule.

To translate expressions and whole queries four further rules are required which all boil down to a common idea: Functions have a number of recursive operands that can be translated independently from each other. The different combinations of argument-scenarios form different scenarios of the function itself. Functions in this context can not only be actual functions like \texttt{+}, \texttt{GREATEST} or \texttt{fib}), but also any syntactic construct (eg. \texttt{IS BETWEEN}, \texttt{INNER JOIN}, \texttt{UNION}) which can be understood as one computation step with independent arguments. This scheme is also applicable for select- and from-clauses.

Finally, we allow the use of CTEs coming with a couple of complexities. Due to CTEs, it is possible that a recursive SQL-fragment does not contain a callsite directly, but indirectly via referenced CTEs. Furthermore, CTEs can reference other CTEs thus it is necessary to track CTE-dependencies and maintain a list of recursive CTEs while taking shadowing into account.

To retrieve the intermediate representation used by the templates, each scenario is augmented with additional information. Most notably, callsite-arguments are extracted from the surrounding query. I provide a set of inference rules performing this task while handling CTEs the same way as in the rules for scenario generation.

Generated queries usually contain a lot of trivial \texttt{SELECT}s and predicates include unnecessary \texttt{AND TRUE}. Most of the time, I simplified these queries for better readability. This could be easily done automatically.

\section{Preliminaries}\label{approach}

\subsection{Structural Operational Semantics}

A Structural Operational Semantic is an abstract way to define program evaluation step by step. Formally stated, it defines a relation between states of an abstract machine. The relation $\rightarrow$ defines transitions between two states. Writing $S \rightarrow S'$ (read: "$S$ evaluates to $S'$") is just a shorthand for $(S, S') \in \rightarrow$. A relations can be defined with respect to a given environment $E$, so: $E \vdash c \rightarrow c'$. \cite[Ch. 2]{semanticsWithApplications}

A rule may have a number of \textit{premises} $p_1, p_2, \dots, p_n$ that must hold for the rule to be applicable. These premises are written on top of a line above the transistion and may include further rule applications. This way a complete derivation-tree, or a "proof-tree" can be created if the transistion at the root (the bottom) is element of the relation. This proof is at the same time the evaluation we want to perform.

$$\inferrule{
   p_1\\
   p_2\\
   \dots\\
   p_n
}{
    S \rightarrow S'
}\quad\footnotesize{\textsc{(name)}}$$

The provided rules give deterministic evaluation steps, ie. at most one rule is applicable at a time. This makes the rules a bit verbose, but simplifies implementation as no backtracking needs to be implemented to find the applicable rule.

In the case of the scenario analysis the state is $(C, T, q, r)$. $C$ is a ordered set of tuples. $C[\{a, b\}]$ returns a subset of $C$ with elements with an alias of $a$ or $b$. The empty CTE-store is denoted as $\varnothing$. $T$ is a set of aliases of CTEs. $q$ is the input query and $r$ is the result of the analysis. $C$ and $T$ are taken as environment.

The analysis result $r$ is a tuple $(B, R)$ containing a set of nonrecursive (basecase) scenarios in $B$ and a set of recursive scenarios in $R$. Each scenario consists of a predicate $p$ and a query that represents a "slice" of the original UDF $q$. An analysis result with three scenarios could look like this:
$$
\Big(
    \overbrace{\big\{
        \underbrace{
            (p_1, q_1)
        }_{\text{scenario 1}}
    \big\}}^{\text{basecase scenarios}}
    ,
    \overbrace{\big\{
        \underbrace{
            (p_2, q_2)
        }_{\text{scenario 2}},
        \underbrace{
            (p_3, q_3)
        }_{\text{scenario 3}}
    \big\}}^{\text{recursive scenarios}}
\Big)
$$

\subsection{Subset of SQL}
Rules to analyze arbitrary queries would need to consider every single language construct. Instead, we focus on a smaller subset of SQL (\autoref{lst:sql_grammar}) to keep the number of rules small and demonstrate the core idea. Generalizations can be added later if necessary. The grammar describes nested \texttt{SELECT-FROM-WHERE} queries (S-F-W) with (nonrecursive) CTEs and query-combining functions.

Functions in the grammar are stated in prefix-notation even if the actual function comes in the form of eg. \texttt{i IS BETWEEN a AND b}, \texttt{x[n]} or \texttt{a IN (<query>)}. Those syntactic details are not visible when represented as AST. All constructs that act like a function are considered a function during translation.

\begin{figure}[h!]
    \begin{minted}{postgresql}
    <query>     ::= [ WITH (<query>) AS <tblAlias>[, ...] ]
                      SELECT <expr>  AS <colAlias>[, ...]
                    [ FROM <tbl>     AS <tblAlias>[, ...] ]
                    [ WHERE <expr> ]
                 |  <query> { UNION | INTERSECT | EXCEPT } [ALL] <query>
    <tbl>       ::= <tblRef> | (<query>) | <fun>([<expr>, ...])
    <expr>      ::=  <const> |  <colRef> |  <fun>([<expr>, ...])
                 |  CASE [WHEN <expr> THEN <expr>, ...] ELSE <expr> END
                 |  ( <query> )
    <fun>       ::= Stable functions
    <const>     ::= SQL built-in constants
    <tblAlias>  ::= alias(colAlias[, ...])
    <colAlias>  ::= alias
    \end{minted}
    \caption{The subset of SQL targeted by the inference rules.}
    \label{lst:sql_grammar}
\end{figure}


%\subsection{No VOLATILE functions}
%Without referential transparancy we cannot assume that two function calls within the same query return the same value, making it impossible to use memoization. Therefore, only UDFs markes as STABLE or IMMUTEABLE (38.7. Function Volatility Categories) are translateable.

A query-fragment $q$ of an UDF named fn \textit{contains a callsite} or \textit{is recursive} if the AST of $q$ contains a node with a call to the $fn$ itself or references a recursive table-variable. The latter is a bit involved (see \autoref{tracking_recursive_ctes}) so we use a simplified variant of $\hasCallsite$ for the beginning that does not take references into account:

$$\hasCallsite(e) = fn \sqsubset e$$

Where $t' \sqsubset t$ means that a node $t'$ is present within the tree $t$.

%The auxiliary function $\sigma_{\text{cols}}$ is used to pick columns from the store by name, eg. $\sigma_{a, t, p, r}(C)$ returns the entire store $\langle (a, t, p, r)_1, \dots, (a, t, p, r)_n \rangle$ and $\sigma_p(C) = \langle p_1, \dots, p_n \rangle$ all predicates in the store.


% UDF is analyzed and a intermediate representation is created that is used as input for the query template. 
% Each scenario consists of a single path through the case-distinctions of the original query. A predicate is generated alongside to detect when this path is taken. Recursive and nonrecursive scenarios are distinguished.
% Scenarios are generated by recursively applying inference rules to the original function-body. The idea behind each rules is first illustrated before the formal definition is presented
% I will begin with four rules necessary to translate the heart of every recurisve UDF, the CASE-expression. Then I will extend the scope to cover arbitrary "function-alikes" from `+` to whole queries. I complete with rules to handle CTEs, which will introduce a couple of complexities that need special considerations.
% Before the scenarios can be used to fill in the query template, some postprocessing is needed. Callsites need to be enumerated and scenarios must be augmented with a list of contained scenarios. Furthermore, arguments must be extracted to individual queries.

%There are two base-rules that require no more rule application and lead to an immidiate result: \RBASE and \RREC. The \RBASE-rule is applicable when a subtree $q$ contains no recursive calls or references to recursive table-expressions. We directly obtain the resulting tuple $(\{q\}, \emptyset)$. The other case is the \RREC-rule, which handles a subtree $q$ where the root node is the recursive call itself. To comply with the overall restrictions given under X.Y.Z, no argument may have a callsite. If this is given, the rule leads directly to $(\emptyset, \{q\})$. TODO: EXPLAN REF

%All other rules require a callsite somewhere within the query, unwrapping each layer of the query until the callsite is reached or no callsite exists in the subtree. The rules for handling \CASE-statements create for each possible outcome one pruned version while extending the given predicate by the predicate of the taken \WHEN-branch. In contrast to SELECT-statements and CASE-expressions, other parts of the query \textit{can} contain callsites in sibling subtrees. The idea here is to compute all possible outcomes of these subtrees independantly and then build the cartesian-product to receive all possible scenarios of the execution of the parent node. The \REXPR-rule implements purely this idea and the \RCTE and \RFROM-rule come as variations or extensions that take distinct particularities into account.

%The most complicated rule is for handling \WITH-statements. As in the \REXPR-rule, each execution-scenario for every CTE is computed and then the cartesion-product is build over all the scanarios. But two difficulties needs to be considered: First, each CTE can reference previous CTEs from within the same WITH-statement. Second, not every CTE may be referenced later on when the actually query (without the CTEs) is processed - eg. the referencing part may be pruned away after application of a \RWHEN-rule. This leads to to multiple identical versions of the original query that only differ in their predicates, namely by the case-distinctions from the unused CTE. This is semantically not a problem but can degrade performance, since callsites are enumerated based on the set of recursive and nonrecursive cases. Unfortunately, it is hardly possible to postpone this step to postprocessing since we would have to identify and remove the parts caused by the unused CTE from the predicate. Thus we hve two rules for handling CTEs: One for processing and removing each CTE one by one from the query and one for reconstructing the original \WITH-Statement, limited to that CTEs that are actually used by the translated query eventually.

%So, how does the CTE-Rules work in detail? Each CTE is processed on its own, one by one. The processed CTE is removed from the query and put into the variable-store and added alongside with its predicate to the temporary CTE-list. Depending on the processed CTE the recursive or nonrecursive store/list is choosen. Computation continues as long as CTEs are present. Finally, the complete query including CTEs is reconstructed. The actual query is translated with emptied temporary CTE-lists. Only CTEs that are referenced (directly or indirectly) are kept and their predicates are appended to the result predicate. To find out what CTEs are referenced, all free variables under the given environment need to be recursivly followed.

\section{Translating simple \texttt{CASE}-expressions}
% Goal is to translate a simple CASE-statement
% Start with primitive rules that do not recurse
% Within CASE-expressions the callsite can be located at two different places: WHEN and THEN
% CASE-expressions can be nested, again this can happen in the WHEN and in the THEN part.

For this section we focus on the rules involved in every translation. First, those are two axioms which will eventually add an expression either to $B$ or to $R$. Secondly, those are rules for handling \texttt{CASE}-expressions. I will illustrate the different possible situations needed to be considered when processing a \texttt{CASE}-expression, before formalizing the \RWHEN-rule. With those four rules it is already possible to analyze very simple expressions.

\subsection{Callsites and basecases}

The leafs of every derivation tree are axioms. The two most important axioms are \RREC~ and \RBASE~ (see \autoref{rule:base_and_rec}). They assign a query-fragment either to the set of recursive ($R$) or non-recursive scenarios ($B$). The distinction is made by the presence of a \textit{callsite} in the given query-fragment. The predicate $\hasCallsite(T, e)$\footnote{Please ignore the argument $T$ of $\hasCallsite$ and the environment $T, C$ of the rules for now, we will come back to this later.} returns true if an actual recursive call to $fn$ is located in the subtree of the AST-representation of the query-fragment $e$.

%The inference rules are applied recursively to an initial query, processing each layer one by one. In the end, each derivation treeare two axioms\footnote{By definition, an axiom has no premises. Premises without further rule application are actually side-constraints that limit rule applicability. Therefore this rules are considered anyway "axioms".}. Either we arrive at a \textit{callsite}, ie. the invocation of the recursive function itself, or the current subtree contains no callsite at all. In the latter case, it is not necessary to descend any further, we can consider the remaining subtree as basecase.

\begin{figure}[h]\small
    \begin{minipage}[b]{\linewidth}
    \centering % BASE
    
  $$
\quad(\textsc{base})\inferrule{
   \neg \hasCallsite(T, e) \\
   \neg \text{isElse}(e)
}{
    T, \varnothing \vdash (p, e) \rightarrow (\{(p, e)\},\{\})
}$$
    \subcaption{}\label{rule:base}
    \end{minipage}\\
    \begin{minipage}[b]{\linewidth}
    \centering % REC
$$\quad(\textsc{rec})\inferrule{
   \forall i \in \{1, ..., n\} : \neg \hasCallsite(T, x_i)
}{
    T, C \vdash (p, fn(x_1, ..., x_n)) \rightarrow (\{\}, \{(p, fn(x_1, ..., x_n))\})
}
$$
    \subcaption{}\label{rule:rec}
    \end{minipage}
    \caption{Rule (a) assigns any query-fragment to $B$ if it does not contain any callsites. (b) Does handle callsites by adding them to $R$. For now, please ignore $T$ and $C$.}\label{rule:base_and_rec}
\end{figure}

The \RREC-rule enforces the overall constraint that no callsite may have a recursive argument. This restriction is due to the strategy how the callgraph is built. It is based on evaluating the arguments of the callsites independently from the whole query. If the arguments itself would be recursive this would not be possible.

\subsection{Simple \CASE-expressions}
\begin{wrapfigure}{r}{.3\textwidth}\centering
\begin{minted}{postgresql}
CASE WHEN p1 THEN r1
     WHEN p2 THEN r2
     ELSE         r3
END
\end{minted}
\caption{A simple \texttt{CASE}-expression}\vspace{-5mm} 
\label{lst:case}
\end{wrapfigure}

The other rules endeavoured in every nontrivial translation are those for handling \texttt{CASE}-expressions (\autoref{lst:case}). They are the original source of any scenario generated. \texttt{CASE}-expressions are \textit{conditional-expression}, other conditionals are \texttt{COALESCE}, \texttt{NULLIF}, \texttt{GREATEST} and \texttt{LEAST}. All of them can be rewritten as \texttt{CASE} (see \autoref{conditional_normalization}).

\texttt{CASE}-expressions in general are a handy way of writing nested \texttt{IF}s. Each \texttt{WHEN} implies all preceding \texttt{WHEN}s to have failed. Therefore each \texttt{WHEN} contains an implicit negation of all preceding \texttt{WHEN}s. The goal is to extend the predicate of a singular \texttt{WHEN} in order to make the actual whole predicate explicit. This way one can unnest the "IFs" to be evaluable independently from each other.

\autoref{flow:simple_case} visualizes the logical flow of a simple \texttt{CASE}-expression with callsites located in the first \texttt{WHEN} and in the \texttt{ELSE}-branch. An arrow to the right means the predicate is fulfilled, an arrow down denotes the negation. Predicates $p_i$ are surrounded by a single lined border while a doubled bordered box marks a possible result $r$ of the \texttt{CASE}-statement. An asterisk $\ast$ indicates a query-fragment including a recursive subexpression (according to $\hasCallsite$).

The segmented rectangles on the right (\autoref{scenarios:simple_case}) depict the generated scenarios from the \texttt{CASE}-expression. The asterisk flags a scenario as recursive, ie. $\in R$, otherwise $\in B$. The second segment contains the predicate of the scenario followed by the query, the actual slice of the original UDF.

\begin{figure}[h!]
    \begin{minipage}[b]{.45\linewidth}
    \centering
    \begin{tikzpicture}[x=20mm, y=20mm]
        \tikzset{Pred/.style={shape=rectangle, draw, minimum width=1cm, minimum height=1cm}}
        \tikzset{Res/.style={shape=rectangle, draw, double distance=0.5mm, outer sep=0.5mm, minimum width=1cm, minimum height=1cm}}
        
        % nodes
        \node[Pred] (p1) at (0, 2) {$p_1$};
        \node[Res]  (r1) at (1, 2) {$\ast r_1$};
        
        \node[Pred] (p2) at (0, 1) {$p_2$};
        \node[Res] (r2) at (1, 1) {$r_2$};
        
        \node[Res] (r3) at (1, 0) {$\ast r_3$};
        
        % arrows
        \draw[->] (p1) -> (r1);
        \draw[->] (p1) -- (p2);
        \draw[->] (p2) -- (r2);
        \draw[->] (p2) |- (r3);
    \end{tikzpicture}
    \subcaption{Logical flow of a simple \CASE-expression with callsites in $r_1$ and $r_3$.}\label{flow:simple_case}
    \end{minipage}\hfill
    \begin{minipage}[b]{.45\linewidth}
    \centering 
    \begin{tikzpicture}[x=20mm, y=20mm]
        \node (case1) at (5, 2) {\begin{tabular}{|p{3mm}|p{5em}|p{2em}|}\hline
        \cellcolor{gray!25} $\ast$ & $p_1$ & $r_1$\\\hline
        \end{tabular}};
        
        \node (case1) at (5, 1) {\begin{tabular}{|p{3mm}|p{5em}|p{2em}|}\hline
        \cellcolor{gray!25} ~~ & $\neg p_1 \land p_2$ & $r_2$\\\hline
        \end{tabular}};
        
        \node (case1) at (5, 0) {\begin{tabular}{|p{3mm}|p{5em}|p{2em}|}\hline
        \cellcolor{gray!25} $\ast$ & $\neg p_1 \land \neg p_2$ & $r_1$\\\hline
        \end{tabular}};
    \end{tikzpicture}
    \subcaption{Generated scenarios for each branch of the \CASE-expression.}\label{scenarios:simple_case}
    \end{minipage}
    \caption{}
\end{figure}

%\setlength{\tabcolsep}{2pt}

\subsection{Recursive \WHEN's}

Recursive predicates cannot be evaluated during callgraph creation and therefore are considered as part of the result (recursive) expression. Slicing stops \textit{before} the recursive predicate and the entire remaining \texttt{CASE}-expression is considered a single big recursive scenario.

\begin{figure}[h!]
    \centering
\begin{tikzpicture}[x=20mm, y=20mm]
\tikzset{Pred/.style={shape=rectangle, draw, minimum width=1cm, minimum height=1cm}}
\tikzset{Res/.style={shape=rectangle, draw, double distance=0.5mm, outer sep=0.5mm, minimum width=1cm, minimum height=1cm}}

% nodes
\node[Pred] (p1) at (0, 1.5) {$p_1$};
\node[Res]  (r1) at (1, 1.5) {$r_1$};
\node at (4, 1.5) {\begin{tabular}{|p{3mm}|p{5em}|p{2em}|}\hline
\cellcolor{gray!25} & $p_1$ & $r_1$\\\hline
\end{tabular}};

\node[Res, inner sep=3mm] (res) at (0.5, 0) {
    \begin{tikzpicture}[x=20mm, y=20mm, inner sep=1em]
        \node (p2) at (0, 1) {$\ast p_2$};
        \node (r2) at (1, 1) {$r_2$};
        \node (r3) at (1, 0) {$r_3$};
        \draw[->] (p2) -- (r2);
        \draw[->] (p2) |- (r3);
    \end{tikzpicture}
};
\node at (4, 0) {\begin{tabular}{|c|c|c|}\hline
\cellcolor{gray!25} $\ast$ & $\neg p_1$ & $\CASE ~ \WHEN ~p_2~ \THEN ~r_2~ \ELSE ~r_3~\END$\\\hline
\end{tabular}};
% arrows
\draw[->] (p1) -> (r1);
\draw[->] (p1) -> (0, 0.95);
\end{tikzpicture}
    \caption{Logical flow and resulting scenarios of a \texttt{CASE}-expression with a recursive predicate. Everything after and including the recursive predicate is considered one single recursive scenario.}
    \label{fig:my_label}
\end{figure}

This introduces an important overall constraint: No more callsites after a recursive predicate. The template for the callgraph creation assumes all callsites in a scenario will be evaluated. The translation evaluates both callsites if they occur in the same scenario, even if the evaluation of one callsite is actually conditioned by the evaluation of another. This would cause runtime errors or nontermination.

\subsection{Nonrecursive subtrees}
Subtrees with no callsite are taken as one big basecase. There is no need to do any further analysis because there are no more callsites that need to be separated into their evaluation scenarios so the callgraph can be built. In this case the \RBASE-rule just adds the entire remaining \texttt{CASE}-expression to $B$.

\begin{figure}[h!]
    \centering
\begin{tikzpicture}[x=20mm, y=20mm]
\tikzset{Pred/.style={shape=rectangle, draw, minimum width=1cm, minimum height=1cm}}
\tikzset{Res/.style={shape=rectangle, draw, double distance=0.5mm, outer sep=0.5mm, minimum width=1cm, minimum height=1cm}}

% nodes
\node[Pred] (p1) at (0, 1.5) {$p_1$};
\node[Res]  (r1) at (1, 1.5) {$\ast r_1$};
\node at (4, 1.5) {\begin{tabular}{|p{3mm}|p{5em}|p{2em}|}\hline
\cellcolor{gray!25} $\ast$ & $p_1$ & $r_1$\\\hline
\end{tabular}};

\node[Res, inner sep=3mm] (res) at (0.5, 0) {
    \begin{tikzpicture}[x=20mm, y=20mm, inner sep=1em]
        \node (p2) at (0, 1) {$p_2$};
        \node (r2) at (1, 1) {$r_2$};
        \node (r3) at (1, 0) {$r_3$};
        \draw[->] (p2) -- (r2);
        \draw[->] (p2) |- (r3);
    \end{tikzpicture}
};
\node at (4, 0) {\begin{tabular}{|c|c|c|}\hline
\cellcolor{gray!25} ~~ & $\neg p_1$ & $\CASE ~ \WHEN ~p_2~ \THEN ~r_2~ \ELSE ~r_3~\END$\\\hline
\end{tabular}};
% arrows
\draw[->] (p1) -> (r1);
\draw[->] (p1) -> (0, 0.95);
\end{tikzpicture}
    \caption{A \texttt{CASE}-expression where no of the later branches have a callsite. Therefore the \RBASE-rule takes them all as a basecase.}
    \label{fig:case_nonrecursive}
\end{figure}


\subsection{Nested \texttt{CASE}-expressions}

\texttt{CASE}-expression can be nested. Nesting can happen either within the predicate of the \texttt{WHEN}-part or within the result of \texttt{THEN}-part. Since dependant callsites are forbidden, either the predicate or the result can have a nested \texttt{CASE}-expression with a callsite, but never both. If there is a nested \texttt{CASE}-expression without a callsite it is left unchanged (\RBASE-rule).

If a \CASE-expression is located in the \texttt{THEN}-part the inner expression is analyzed independently. The predicate from the outer scenario is prepended to the predicates of the scenarios generated by the inner \CASE-expression.

%Predicates must be evaluable directly for our translation template, ie. no callsite may be present in any predicate. Therefore, as soon as a predicate appears to be recursive, the recursive predicate is considered part of the recursive result and the evaluation of the \CASE-expression halts with the remaining \CASE-expression which forms an recursive case as a whole.
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[x=20mm, y=20mm]
\tikzset{Pred/.style={shape=rectangle, draw, minimum width=1cm, minimum height=1cm}}
\tikzset{Box/.style={shape=rectangle, draw, minimum width=1cm, minimum height=1cm, dotted, very thick}}
\tikzset{Res/.style={shape=rectangle, draw, double distance=0.5mm, outer sep=0.5mm, minimum width=1cm, minimum height=1cm}}

% nodes
\node[Pred] (p) at (0.5, 1) {$p$};
\node[Box]  (r1) at (2, 1) {
    \begin{tikzpicture}[x=15mm, y=15mm]
        \node[Pred] (p1) at (0, 2) {$p_1$};
        \node[Res] (r1) at (1, 2) {$r_1$};
        
        \node[Pred] (pi) at (0, 1) {$p_2$};
        \node[Res] (ri) at (1, 1) {$r_2$};
        
        \node[Res] (rn) at (1, 0) {$\ast r_3$};
        % arrows
        \draw[->] (p1) -- (r1);
        \draw[->] (pi) -- (ri);
        \draw[->] (p1) -- (pi);
        \draw[->] (pi) |- (rn);
    \end{tikzpicture}
};
\node at (5, 1.75) {
    \begin{tabular}{|p{1em}|p{2.5cm}|c|}\hline
    \cellcolor{gray!25}  & $p \land \phantom{\neg}p_1$ & $r_1$\\\hline
    \end{tabular}
};
    
\node at (5, 1) {
    \begin{tabular}{|p{1em}|p{2.5cm}|c|}\hline
    \cellcolor{gray!25}  & $p \land \neg p_1 \land \phantom{\neg} p_2$ & $r_2$\\\hline
    \end{tabular}
};

\node at (5, 0.25) {
    \begin{tabular}{|p{1em}|p{2.5cm}|c|}\hline
    \cellcolor{gray!25}$\ast$   & $p \land \neg p_1 \land \neg p_2$ & $r_3$\\\hline
    \end{tabular}
};
   
% arrows
\draw[->] (p) -- (r1);
\end{tikzpicture}
    \caption{Nested \texttt{CASE} in the \texttt{THEN}-part.}
    \label{fig:case_nested_in_when}
\end{figure}

If a recursive \texttt{CASE}-expression is nested inside the \texttt{THEN}-part, it is analyzed and number of scenarios is returned. The particularity here is that the results of the scenarios are predicates. Thus, the scenario of the nested \texttt{CASE}-expression contains a predicate and a predicate for the predicate. Therefore both, the predicate and the result of the inner scenario, need to be added to the predicate of the scenario of the outer \texttt{CASE}-expression.

\begin{figure}[h!]
    \centering
\begin{tikzpicture}[x=15mm, y=12mm]
\tikzset{Pred/.style={shape=rectangle, draw, minimum width=1cm, minimum height=1cm}}
\tikzset{Box/.style={shape=rectangle, draw, minimum width=1cm, minimum height=1cm, dotted, very thick}}
\tikzset{Res/.style={shape=rectangle, draw, double distance=0.5mm, outer sep=0.5mm, minimum width=1cm, minimum height=1cm}}

% dash pattern=on 5pt off 1pt on 3pt off 3pt on 1pt off 2pt on 1pt off 2pt on 3pt off 1pt

% nodes
\node[Pred] (p) at (0, 3) {$p$};

\node[Box] (p1) at (0, 1) {
    \begin{tikzpicture}[x=15mm, y=15mm]
        \node[Pred] (p2) at (0, 1) {$\pi_1$};
        \node[Pred] (r2) at (1, 1) {$p_1$};
        \node[Pred] (p3) at (1, 0) {$\ast p_2$};
        % arrows
        \draw[->] (p2) -- (r2);
        \draw[->] (p2) |- (p3);
    \end{tikzpicture}
};
\node[Res] (r1) at (2, 1) {$r_i$};
\node (case1) at (6, 1) {
    \begin{tabular}{|p{1em}|r|c|}\hline
    \cellcolor{gray!25} & $\neg p \land \pi_1 \land \phantom{\neg} p_1$ & $r_i$\\\hline
    \cellcolor{gray!25} & $\neg p \land \pi_1 \land \neg p_1$ & $r$\\\hline
    \end{tabular}
};

\node[Res] (r) at (2, -1) {$r$};
\node (case1) at (6, -1) {
    \begin{tabular}{|p{1em}|r|c|}\hline
    \cellcolor{gray!25} $\ast$ & $\neg p \land \neg \pi_i$ & \texttt{WHEN }$p_2$ \texttt{THEN} $r_i$ \texttt{ELSE} $r$\\\hline
    \end{tabular}
};
% arrows
\draw[->] (p) -- (p1);
\draw[->] (p1) -- (r1);
\draw[->] (p1) |- (r);
\end{tikzpicture}
    \caption{Nested \texttt{CASE} in \texttt{WHEN}-part. Note that neither $r_i$ nor $r$ must contain any callsite.}
    \label{fig:case_nested_when}
\end{figure}

\subsection{\CASE- and \ELSE-rule}

The \RWHEN-rule works branch by branch. It is only applicable if not both, the predicate $p$ and the remaining branches $bs$, contain callsites (1st premise). Predicate $p$ and resulting expression $e$ are analyzed, obtaining scenarios $(B_p, R_p)$ for the predicate and $(B_e, R_e)$ for the resulting expression (2nd and 3rd premise). The nonrecursive scenarios of the predicate $B_p$ contain $n$ tuples of a predicate (of the scenario, ie. the "predicate of the predicate") and a result, the actual predicate (4th premise).

The last premise analyzes the remaining branches for those scenarios where the predicate is nonrecursive (from $B_p$). The predicate of the remaining branches is thus prepended to the (positive) predicate of the predicate $p_p$ and the negated actual predicate $p'$. The scenarios of later branches are added by the actual rule to the set of non-/recursive scenarios.

\begin{figure}[h!]
    \centering\footnotesize

  \makebox[\textwidth][c]{$$\inferrule{
    \neg (\hasCallsite(T, p) \land \hasCallsite(T, bs))\\\\
    T, C \vdash (\TRUE, p) \rightarrow (B_p, R_p) \\\\
    T, C \vdash (\TRUE, e) \rightarrow (B_e, R_e)\\\\
    B_p = \{(p_{p_1}, p'_1), ..., (p_{p_n}, p'_n)\} \\\\
    \forall 1 \leq i \leq n : T, C \vdash (p_0 ~\AND~ p_{p_i}~\AND~\NOT~ p'_i,~ \CASE~ bs ~\END) \rightarrow (B_i, R_i) \\
}{
T, C \vdash (p_0, \CASE~ \WHEN ~p ~\THEN ~e ~bs ~\END) \rightarrow \\
{\begin{tabular}{L}
         \Big( \Big\{\big(p_0 ~\AND~ p_p         ~\AND~ p' ~\AND~ p_e , e'\phantom{\CASE ~ \WHEN ~  ~ \THEN ~e ~bs~ \END}\big) ~|~~(p_p, p') \in B_p, (p_e, e') \in B_e \Big\} \cup~ (\cup_{1\leq i \leq n}B_i)~~~~,\\[2mm]
\phantom{\Big(}\Big\{\big(p_0 ~\AND~ p_p         ~\AND~ p' ~\AND~ p_e , e'\phantom{\CASE ~ \WHEN ~  ~ \THEN ~e ~bs ~\END}\big) ~|~~(p_p, p') \in B_p, (p_e, e') \in R_e \Big\} \cup~ (\cup_{1\leq i \leq n}R_i) ~\cup\\
\phantom{\Big(}\Big\{\big(p_0 ~\AND~ p_p\phantom{~\AND~ p' ~\AND~ p_e},            \CASE ~ \WHEN ~p'~ \THEN ~e ~bs ~\END \big) ~|~~(p_p, p') \in R_p~~~~~~~~~~~~~~~~~  \Big\}~~~~~~~~~~~~~~~~~~~~~~~~~ \Big)
\end{tabular}}
}\quad(\textsc{when})$$}
    \caption{\RWHEN-rule to slice \texttt{CASE}-expressions into its different evaluation scenarios.}
    \label{rule:when}
\end{figure}

The actual rule combines all sources of scenarios. The basecase scenarios (first component of the tuple) are built by combining all nonrecursive predicates ($B_p$) with the nonrecursive resulting expressions ($B_e$). This set of scenarios is unioned with the $n$ sets of scenarios of the other branches $(B_i, R_i)$ (remember $n$ is the number of nonrecursive predicate-scenarios).

Analogously, the same happens for the second component of the tuple, the recursive scenarios. This time nonrecursive predicate-scenarios ($B_p$) are combined with recursive resulting expression scenarios ($B_e$). Additionally, scenarios with recursive predicates ($R_p$) are added.

As soon as all branches are processed a single \texttt{ELSE} remains. This is not valid SQL, therefore the \RBASE-rule has a premise that restricts applicability here. Thus we need the \RELSE-rule to take care unwrapping the result of this trivial conditional.
\begin{figure}[h!]
    \centering\small
$$\inferrule{
    T, C \vdash (p, e) \rightarrow (B, R) \\
}{
    T, C \vdash (p, \CASE ~\ELSE ~e~ \END) \rightarrow (B, R)
}
\quad(\textsc{else})$$
    \caption{\RELSE-rule.}
    \label{fig:my_label}
\end{figure}

With the four rules of the previous section very simple \texttt{CASE}-expressions (with constants or callsites only) can be analyzed. Nonrecursive subtrees of the AST are handled by the \RBASE-rule while callsites are considered with the \RREC-rule. In the following section rules are introduced to traverse expressions like \texttt{1 + fn(...)}.

\section{Handling recursive operands}

Expressions like \texttt{1 + fn(...)} cannot be translated by the \RBASE-rule nor by the \RREC-rule because of the callsite not being at the root of the AST but in one of its subtrees. At the root, there is the \texttt{+}-operator, the left subtree is the constant \texttt{1} and the right subtree the callsite \texttt{fn(...)} (\autoref{ast:expr}).

\begin{wrapfigure}{r}{.3\textwidth}
  \centering
  \begin{tikzpicture}
  \node[draw, circle] (plus) at (1,1) {\texttt{+}};
  \node (one) at (0,0) {\texttt{1}};
  \node (fn) at (2,0) {\texttt{fn}};
  \draw[->] (plus) to node[pos=0.5, left, label distance=5mm]{\tiny{larg}} (one);
  \draw[->] (plus) to node[pos=0.5, right, label distance=5mm]{\tiny{rarg}} (fn);
  \draw[dotted, thick] (fn) to +(-0.5, -0.5);
  \draw[dotted, thick] (fn) to +(0, -0.5);
  \draw[dotted, thick] (fn) to +(0.5, -0.5);
  \end{tikzpicture}
  \caption{AST-representation of \texttt{1 + fn(...)}.}
  \label{ast:expr}
\end{wrapfigure}

The \REXPR-rules purpose is to traverse the AST and analyze each subtree independently. I am using the generic term of a \textit{function} to refer to syntactic constructs consisting of a node with multiple subtrees independent from each other. These includes built-in functions, UDFs, operators, aggregates, subquery expressions (eg. \texttt{n IN (...)}), row-comparisons, array-element access, arrays itself and \texttt{VALUES}-lists. The last may be surprising at first, but \texttt{(VALUES (1), (2), (3))} or \texttt{ARRAY[1, 2, 3]} is nothing different from a constructor -- a function.

Multiple evaluation scenarios may be obtained for each subtree. These scenarios need to be combined again to return the different evaluation scenarios of the function itself. This is done by building the cross product between the scenarios of each subtree. We obtain all possible combinations of evaluation scenarios of the subtrees, constituting the scenarios of the function (\autoref{fig:expr-expr}).

\begin{figure}[h]
    \centering
    \input{tikz/expr-expr.tex}
    \caption{Operands of a function are translated separately. For each operand a number of scenarios is generated. All possible scenarios of the original function are created by using the cross product.}
    \label{fig:expr-expr}
\end{figure}

\iffalse
$
\inferrule*[Right=(expr)]{
    \inferrule*[Left=(rec)]{ }{
        {\begin{minipage}[b]{15em}
        \mintinline{postgresql}{(TRUE, fib($1 - 1)) ->}
        \mintinline{postgresql}{({}, {(TRUE, fib($1 - 1))})}
        \end{minipage}}
    }\\
    \inferrule*[Right=(rec)]{ }{
        {\begin{minipage}[b]{15em}
        \mintinline{postgresql}{(TRUE, fib($1 - 2)) ->}
        \mintinline{postgresql}{({}, {(TRUE, fib($1 - 2))})}
        \end{minipage}}
    }
}{
    {\begin{minipage}[b]{25em}
    \mintinline{postgresql}{(TRUE, fib($1 - 1) + fib($1 - 2)) ->}
    \mintinline{postgresql}{({}, {(TRUE AND TRUE AND TRUE, fib($1 - 1) + fib($1 - 2))})}
    \end{minipage}}
}
$
\fi

The \REXPR-rule formalizes this idea (\autoref{rule:expr}). $\oplus$ is used as meta-variable for any suitable function etc. Each subtree $e_i$ is translated independently, resulting in the $1 \leq i \leq n$ tuples of scenarios $(B_i, R_i$). Note that the rule is only applicable if at least on subtree contains a callsite. Otherwise it would overlap with \RBASE.

\begin{figure}[h!]
    \centering
  \makebox[\textwidth][c]{$$\inferrule{
    \exists i \in \{1, ..., n\}: \hasCallsite(T, e_i)\\
    \forall i \in \{1, ..., n\}: T, C \vdash (\TRUE, e_i) \rightarrow (B_i, R_i)
}{
    T, C \vdash (p, \oplus_{1\leq i \leq n} e_i) \rightarrow \\\\
    {\begin{tabular}[b]{L}
                 \Big( \big\{(p ~\AND~ (\AND_{1\leq i \leq n} p_i)), \oplus_{1\leq i \leq n} e_i'           ~|~~ ((p_1, e_1'), ..., (p_n, e_n')) \in \times_{\{i|1\leq i \leq n\}} \phantom{(}B_i~~~~~~~~~\big\}, \\
        \phantom{\Big(}\big\{(p ~\AND~ (\AND_{1\leq i \leq n} p_i)), \oplus_{1\leq i \leq n} e_i ~|~~ ((p_1, e_1'), ..., (p_n, e_n')) \in \times_{\{i|1\leq i \leq n\}} (B_i \cup R_i),\\
        \hspace*{65mm}\exists e \in \{e'_1, ..., e'_n\} : \hasCallsite(T, e)~~~~~~~~~\big\}~\Big)
    \end{tabular}}
}\quad(\textsc{expr})$$}
    \caption{\REXPR-rule}
    \label{rule:expr}
\end{figure}

Nonrecursive scenarios of the function are created by replacing each argument with the expression from one of its scenarios. The cross product between all nonrecursive scenarios $B_i$ is used to build a set of all possible combinations of nonrecursive scenarios. The predicates $p_i$ of the scenario of each of the $n$ arguments are all unioned by \texttt{AND}. The arguments of the original function are replaced with the expressions generated by the scenarios.

To create all scenarios of a function where at least one argument is recursive, the cross product between all scenarios of an argument (recursive and nonrecursive) is built. Only those combinations where at least one expression is recursive, are kept.

To translate entire queries the three different parts of a query are needed to be traversed: The \texttt{SELECT}-list, the \texttt{FROM}-list and the predicate in \texttt{WHERE}. The idea from the \REXPR-rule applies here as well, but some additional premises must hold. Only one of the three clauses may be recursive. If the \texttt{WHERE}-clause contains a callsite any other callsites located elsewhere in the query would depend on that specific callsite. If a callsite is present in the \texttt{FROM}-list, the execution of the callsites within \texttt{SELECT}- and \texttt{WHERE}-clauses would depend on the callsite in the \texttt{FROM}-list. Therefore only one of the three parts of a query may contain a callsite.

As of now, there are three different rules to analyze callsites in each clause of a query. In the future, they could probably be combined into an extended version of the \REXPR-rule as all four rules do basically the same.

\begin{figure}[h!]
    \centering
    \input{tikz/expr-select.tex}
    \caption{The projection of a relation happening inside \SELECT~can be understood as a function as well as \FROM-clause.}
    \label{fig:expr-select}
\end{figure}

The idea of analyzing queries with callites in the select-list follows directly the idea of the \REXPR-rule (\autoref{fig:expr-select}). Each target from the \texttt{SELECT}-list is analyzed independently and used to reconstruct the actual \texttt{SELECT}. Other parts of the query are unchanged and will not be analyzed at all since they have to be nonrecursive.

The inference rule (\autoref{rule:select}) is nearly identical to the \REXPR-rule. Only additional premises enforce the constraints stated above. Furthermore, the "function" representing the query is not entirely analyzed, only the \texttt{SELECT}-clause is. Other clauses do not contain callsites and would lead to the application of the \RBASE-rule leaving them unchanged.

\begin{figure}[h!]
    \centering\scriptsize
  \makebox[\textwidth][c]{
$$\inferrule{
    \exists i \in \{1, ..., n\}: T \vdash \hasCallsite(e_i) \\
    \neg \hasCallsite(T, ts) \\
    \neg \hasCallsite(T, w) \\\\
    \forall i \in \{1, ..., n\}: T, \varnothing \vdash (\TRUE, e_i) \rightarrow (B_i, R_i)
}{
    T, \varnothing \vdash (p, \SELECT~ e_1, ..., e_n ~\FROM ~ts ~\WHERE~w) \rightarrow \\\\
    {\begin{tabular}[b]{L}
             \Big( \big\{\big(\SELECT~ p ~\AND~ p_1 ~\AND~ \cdots ~\AND~ p_n, ~\SELECT~ e'_1, ..., e'_n ~\FROM ~ts~\WHERE ~w \big) | ~((p_1, e'_1), ..., (p_n, e'_n)) \in \times_{1 \leq i \leq n} B_i~~~~~~~~~\big\}, \\
    \phantom{\Big(}\big\{\big(\SELECT~ p ~\AND~ p_1 ~\AND~ \cdots ~\AND~ p_n,~ \SELECT~ e'_1, ..., e'_n ~\FROM ~ts~ \WHERE~w \big) | ~((p_1, e'_1), ..., (p_n, e'_n)) \in \times_{1 \leq i \leq n} (B_i \cup R_i),\\
    \hspace{96mm}\exists e \in \{e'_1, ..., e'_n\} : \hasCallsite(T, e)~~~~~~\big\}\Big)\\
    \end{tabular}}
}
\quad(\textsc{select})$$}
    \caption{\RSELECT-rule}
    \label{rule:select}
\end{figure}




A recursive \texttt{FROM}-clause works analogously, the \RFROM-rule is nearly identical to the \RSELECT-rule (\autoref{rule:from}). Instead of the \texttt{SELECT}-list the \texttt{FROM}-list is analyzed. Other parts of the query cannot contain callsites thus are left unchanged.

\begin{figure}[h!]
    \centering\scriptsize
  \makebox[\textwidth][c]{
$$\inferrule{
    \exists i \in \{1, ..., n\}: T \vdash \hasCallsite(e_i) \\
    \neg \hasCallsite(T, ts) \\
    \neg \hasCallsite(T, w) \\\\
    \forall i \in \{1, ..., n\}: T, \varnothing \vdash (\TRUE, e_i) \rightarrow (B_i, R_i)
}{
    T, \varnothing \vdash (p, \SELECT~ ts ~\FROM ~e_1, ..., e_n ~\WHERE~w) \rightarrow \\\\
    {\begin{tabular}[b]{L}
             \Big( \big\{\big(\SELECT~ p ~\AND~ p_1 ~\AND~ \cdots ~\AND~ p_n, ~\SELECT ~ts~ \FROM ~e'_1, ..., e'_n~\WHERE ~w \big) | ~((p_1, e'_1), ..., (p_n, e'_n)) \in \times_{1 \leq i \leq n} B_i~~~~~~~~~\big\}, \\
    \phantom{\Big(}\big\{\big(\SELECT~ p ~\AND~ p_1 ~\AND~ \cdots ~\AND~ p_n,~ \SELECT ~ts~ \FROM ~e'_1, ..., e'_n~ \WHERE~w \big) | ~((p_1, e'_1), ..., (p_n, e'_n)) \in \times_{1 \leq i \leq n} (B_i \cup R_i),\\
    \hspace{96mm}\exists e \in \{e'_1, ..., e'_n\} : \hasCallsite(T, e)~~~~~~\big\}\Big)\\
    \end{tabular}}
}
\quad(\textsc{from})$$}
    \caption{\RFROM-rule}
    \label{rule:from}
\end{figure}


\iffalse
\begin{figure}[h!]
    \centering\footnotesize
  \makebox[\textwidth][c]{
$$\inferrule{
    \exists i \in \{1, ..., n\}: \hasCallsite(T, e_{f_i}) \\
    \neg \hasCallsite(T, ts)\\
    \neg \hasCallsite(T, w) \\\\
    \forall i \in \{1, ..., n\}: T, \varnothing \vdash (\TRUE, t_i) \rightarrow (B_i, R_i)
}{
T, \varnothing \vdash (p, \SELECT~ ts ~\FROM~ t_1 \AS a_1 \otimes ... \otimes  t_n \AS a_n ~\WHERE~ w) \rightarrow \\\\
{\begin{tabular}[b]{LLLL}
         \Big( \big\{ (\SELECT~ p ~\AND~ p_1 ~\AND~ \cdots ~\AND~ p_n,~ \SELECT~ ts ~\FROM~ t'_1 \AS a_1 \otimes ... \otimes  t'_n \AS a_n ~\WHERE~ w ~~)\\
\phantom{\Big( \big\{}| ~((p_1, t'_1), ..., (p_n, t'_n)) \in \times_{\{i|1\leq i \leq n\}} B_i \hspace*{80mm}\big\}, \\
\phantom{\Big(}\big\{ (\SELECT~ p ~\AND~ p_1 ~\AND~ \cdots ~\AND~ p_n,~ \SELECT~ ts ~\FROM~ t'_1 \AS a_1 \otimes ... \otimes  t'_n \AS a_n ~\WHERE~ w ~~)\\
\phantom{\Big( \big\{}| ~ ((p_1, t'_1), ..., (p_n, t'_n)) \in \times_{\{i|1\leq i \leq n\}} (B_i \cup R_i), \exists t' \in \{t'_1, ..., t'_n\} : \hasCallsite(t') \hspace*{17mm}\big\}\Big)\\
\end{tabular}}
}
\quad(\textsc{from})
$$
}
    \caption{\RFROM-rule}
    \label{rule:from}
\end{figure}
\fi

Finally, the callsite may be located inside the where-clause of the query. The \RWHERE-rule (\autoref{rule:where}) is more simple because of just a single expression that needs to be analyzed and replaced in the query. Other parts of the query do not have to be considered.

%Probably all three rules to handle queries could be combined into a single rule. The premises would need to enforce that exactly one of the three parts contains a callsite and the actual rule would analyze all parts of the query. If we augment the \REXPR-rule with appropriate premises, all three rules could probably be replaced by the \REXPR-rule.

\begin{figure}[h!]
    \centering\small
  \makebox[\textwidth][c]{
$$\inferrule{
    \neg \hasCallsite(T, ts) \\
    \neg \hasCallsite(T, es) \\
    \hasCallsite(T, w) \\\\
    T, \varnothing \vdash (p, w) \rightarrow (B, R)
}{
    T, \varnothing \vdash (p, \SELECT~ es ~\FROM ~ts~ \WHERE~w) \rightarrow \\\\
    {\begin{tabular}[b]{L}
             \Big( \big\{\big(\SELECT~ p', ~\SELECT ~es~ \FROM ~ts~ \WHERE ~w' \big) | ~(p', w') \in B\big\}, \\
    \phantom{\Big(}\big\{\big(\SELECT~ p', ~\SELECT ~es~ \FROM ~ts~ \WHERE ~w' \big) | ~(p', w') \in R\big\}\Big)\\
    \end{tabular}}
}
\quad(\textsc{where})$$}
    \caption{\RWHERE-rule}
    \label{rule:where}
\end{figure}


\iffalse
$$\quad(\textsc{where})\inferrule{
    T \vdash \neg \hasCallsite(e_{s}) \\
    \forall i \in \{1 \leq i \leq n\} : T \vdash \neg \hasCallsite(e_{t_i}) \\
    T \vdash \hasCallsite(e_{w}) \\
    T, \varnothing \vdash (p, e_{w}) \rightarrow (B, R)
}{
    T, \varnothing \vdash (p, \SELECT~ e_s ~\FROM~ t_1 ~\AS~ a_1 \otimes ... \otimes t_n ~\AS~ a_n ~\WHERE~ e_w) \rightarrow \\\\
    {\begin{tabular}[b]{LLLL}
    (~~&\{&(&\SELECT~ p_w  ~\FROM~ t_1 ~\AS~ a_1 \otimes ... \otimes  t_n ~\AS~ a_n ~\WHERE~ e'_w,\\
        &&&\SELECT~ e_s ~\FROM~ t_1 ~\AS~ a_1 \otimes ... \otimes  t_n ~\AS~ a_n ~\WHERE~ e'_w~~) \\
        && | &~(p_w, e'_w) \in B~~\}, \\
     &\{&(&\SELECT~ p_w ~\FROM~ t_1 ~\AS~ a_1 \otimes ... \otimes  t_n ~\AS~ a_n ~\WHERE~ e'_w, \\
        &&&\SELECT~ e_s ~\FROM~ t_1 ~\AS~ a_1 \otimes ... \otimes  t_n ~\AS~ a_n ~\WHERE~ e'_w~~) \\
        && | &~(p_w, e'_w) \in R~~\}~~)\\
    \end{tabular}}
}$$
\begin{figure}[h!]
    \centering
    \input{tikz/expr-cte.tex}
    \caption{The ~\WITH-clause could also be viewed as composition of functions $\WITH(t, T, q)$ that bind a table-variable \texttt{T} to an expression \texttt{t} for a given query \texttt{q}. In this example it would be $\WITH(T, t, \WITH(S, s, q))$ as CTEs can reference preceding ones.}
    \label{fig:expr-cte}
\end{figure}

\sqlcode[mathescape=true]{snippets/rule_from_example.sql}


$
\inferrule*{
    \inferrule*{...}{
{\begin{minipage}[b]{12em}
\sqlcode{snippets/rules/fib/01-case.sql}
\end{minipage}}
    }
}{
{\begin{minipage}[b]{12em}
\sqlcode{snippets/rules/fib/01-select.sql}
\end{minipage}}
}
$

\fi

Examples for different UDFs utilizing each of the introduced rules are provided in the appendix (\autoref{appendix:analyzes}).


\section{Handling CTEs}

Common Table Expressions (CTEs) are a powerful tool to structure and tweak complex queries. They work like temporary tables which only exist for an individual query. However, allowing CTEs containing callsites introduce some complexities that need to be considered when analyzing.

% Without CTEs hasCallsite just checks the subtree
With S-F-W queries the notion of \textit{containing a callsite} (or being \textit{recursive}) is simple. If a query-fragment $e$ contains a callsite, the subexpression is recursive: $\hasCallsite(e) = fn \sqsubset e$. From an implementation point of view it is as simple as filtering the AST of $e$ for callsites.

\begin{wrapfigure}{r}{.5\textwidth} 
    \begin{minipage}{\linewidth}
    \label{fig:simple_indiref}\par\vfill
    \begin{minted}{postgresql}
    WITH S AS (SELECT f(n-1)),
         T AS (SELECT * FROM S)
    SELECT * FROM T
    \end{minted}
    \subcaption{Neither the actual query nor the referenced CTE \texttt{T} directly contain a callsite.}
    \label{fig:indirect_callsite}\par
    \vspace{3mm}
    \begin{minted}{postgresql}
    SELECT (
        WITH T AS (SELECT f(n-1))
        SELECT 1
    )
    \end{minted}
    \subcaption{Our definition of $\hasCallsite$ would fail here as a callsite is located in the subtree. The query is actually nonrecursive.}
    \label{fig:unused_callsite}
\end{minipage}
\caption{}
\label{lst:indirect_callsite_ref}\vspace{-5mm} 
\end{wrapfigure}

% CTEs introduce indirect callsites that make callsite detection more complicated
With CTEs we need to consider two additional issues: At first, callsites can now be located outside the current subtree by referencing recursive CTEs (\autoref{fig:indirect_callsite}). Secondly, a scenario may contain unused recursive CTEs, fooling $\hasCallsite$ as stated above, to believe a given query-fragment is recursive even if the recursive CTEs are unused thus never evaluated (\autoref{fig:unused_callsite}).

% Removing all CTEs, translating then and then reattaching only used CTEs fixes this.
We can counter these issues by removing the CTEs from the original query before translating the actual query. For each query-scenario only those scenarios of CTEs are reattached afterwards that are actually used (\autoref{tracking_recursive_ctes}). To detect indirect callsite references we note recursive CTEs in a list when detaching (\autoref{tracking_cte_dependencies}) and check against this list if we encounter free table-variables in the query.

\subsection{Tracking recursive CTEs}\label{tracking_recursive_ctes}

\begin{wrapfigure}{r}{0.4\textwidth}
    \begin{minted}{postgresql}
    WITH T AS (SELECT fn(n-1))
    SELECT *
    FROM (
      WITH T AS (SELECT 1)
      SELECT * FROM T
    ) T
    \end{minted}
    \caption{The outer recursive CTE \texttt{T} is shadowed by an inner CTE.}
    \label{lst:indirect_callsite_ref}
\end{wrapfigure}

% Recursive CTEs are gathered step by step 
CTEs may contain callsites and therefore need to be analyzed as well. They are processed step by step before the actual query. This enables a CTE to reference preceding CTEs. If a CTE-scenario contains a callsite its alias is added to the list of recursive CTEs $T$ in scope. Otherwise, the alias is removed from that list because of the new CTE shadows any outer recursive CTE with the same name (\texttt{WITH}-queries can be nested). (\autoref{lst:indirect_callsite_ref}).

Whenever a query-fragment which references a CTE from $T$ is encountered we know this fragment to be recursive. This way we can build up $T$ incrementally and do not need to track each reference recursively back to its declaration in order to find out whether it is recursive. As an example see \autoref{fig:tracking_recursive_ctes}.

\begin{figure}[h]
    \footnotesize
    \centering
    \begin{tikzpicture}[x=8mm, y=8mm]
    \node at (0.5, 1) {\footnotesize{(a)}};
    \node at (5.5, 1) {\footnotesize{(b)}};
    \node at (15.5, 1) {\footnotesize{(c)}};
    \node[anchor=west] at (-1, 0) {\WITH};
    \node[anchor=west] (A) at (0, 0)  {\texttt{A} \AS $(\ast a),$};
    \node[anchor=west] (B) at (0, -1) {\texttt{B} \AS $(b),$};
    \node[anchor=west] (C) at (0, -2) {\texttt{C} \AS $(c),$};
    \node[anchor=west] (D) at (0, -3) {\texttt{D} \AS $(d)$};
    \node[anchor=north west] (S) at (-1, -3.75) {$\underbrace{\SELECT~\texttt{*}~\FROM~\texttt{D}}_q$};
    \node[anchor=west] (Ar) at (3, 0)  {$fn \sqsubset a  \Longrightarrow  \hasCallsite(T, q)$};
    \node[anchor=west] (Br) at (3, -1) {$\FV(b) \cap T = \emptyset \cap \{\texttt{A}\} = \emptyset  \Longrightarrow  \neg \hasCallsite(T, q)$};
    \node[anchor=west] (Cr) at (3, -2) {$\FV(c) \cap T = \{A\} \cap \{A\} \neq \emptyset  \Longrightarrow  \hasCallsite(T, q)$};
    \node[anchor=west] (Dr) at (3, -3) {$\FV(d) \cap T = \{C\} \cap \{A, C\} \neq \emptyset  \Longrightarrow  \hasCallsite(T, q)$};
    \node[anchor=north west] (Dr) at (3, -3.75) {$\FV(q) \cap T = \{D\} \cap \{A, C, D\} \neq \emptyset  \Longrightarrow  \hasCallsite(T, q)$};
    \node[anchor=west] (Ar) at (13.5, 0) {$T := T \cup \{\texttt{A}\} = \{\texttt{A}\}$};
    \node[anchor=west] (Br) at (13.5, -1) {$T := T \setminus \{\texttt{B}\} = \{\texttt{A}\}$};
    \node[anchor=west] (Cr) at (13.5, -2) {$T := T \cup \{\texttt{C}\} = \{\texttt{A}, \texttt{C}\}$};
    \node[anchor=west] (Dr) at (13.5, -3) {$T := T \cup \{\texttt{D}\}= \{\texttt{A}, \texttt{C}, \texttt{D}\}$};
    \draw[->, bend right=60] (C) to (A);
    \draw[->] (C) to (B);
    \draw[->] (D) to (C);
    \end{tikzpicture}
    \caption{a) $q$ has no direct callsite, but reference \texttt{D} contains a reference to \texttt{A} via \texttt{C}. \texttt{A} contains a direct callsite. b) A fragment $e$ is considered recursive if it contains a direct callsite ($fn \sqsubset$ e) or uses a recursive table-variable. c) If $\hasCallsite$ yields true for a CTE-body its alias is added to the set of recursive table-variables $T$. Otherwise, the alias is removed to take into account shadowing.}
    \label{fig:tracking_recursive_ctes}
\end{figure}

% Referenced CTEs are detected via unbound variables
References to CTEs can easily be collected from a query-fragment by searching for free table-variables. The function to compute all free table-variables of a query-fragment $e$ is called $\FV(e)$. Its implementation is straight forward: Each CTE definition within a \WITH-block adds its alias to the list of bound table-variables. Every reference to a table-variable not contained in that list is considered free.

% Row-references vs. table-variables
Note that two different types of free variables inside a query-fragment can occur: \textit{Table-Variables} and \textit{Row-References}. Table-variables like \texttt{T} can exclusively be used in ~\FROM~ and reference an entire table. This table-variables are declared either by the existence of a table in the current database or by a CTE. Row-references like \texttt{T.v} point to a single table-row of a table referenced by ~\FROM. A bare row-reference cannot cause a query to be recursive. It is always the from-clause that declares this row-references and binds it to a table. This table is always evaluated first, no matter whether any row-reference is used at all. For this reason it is sufficient to track only \textit{table}-variables and ignore row-references entirely.

As we now know which CTEs in scope are recursive, we can reformulate the function to determine whether a query-fragment contains a callsite directly or via a reference:
$$\hasCallsite(T, e) = fn(\dots) \sqsubset e \lor \FV(e) \cap T \neq \emptyset$$
Either the callsite is directly contained in $e$ or it contains a free table-variable also enlisted in $T$. Otherwise, the query-fragment is not recursive.

With indirect references we need another axiom for recursive references:

% REF
$$\quad(\textsc{ref})\inferrule{
   \text{isReference}(S) \\
   T \vdash \hasCallsite(S)
}{
    T, C \vdash (p, S) \rightarrow (\{\}, \{(p, S)\})
}$$

%We process CTEs of a \WITH-block top down, before translating the actual \SELECT-query, resembling the way SQL evaluates them. If a CTE \texttt{T} references a CTE \texttt{S} that is recursive, \texttt{T} is also recursive. SQL evaluates CTEs in the order they are defined, so that preceding CTEs can be referenced by following CTEs (figure 4.4a FIXME?). Furthermore, CTEs can be nested so that we need to take care of shadowing out outer CTEs.

%Instead of tracing every reference through the entire query until the initial definition is found, I take an incremental approach: If a new table-variable is created, we check each free variable in its subtree against the environment of known recursive table-references within that scope. If there is a recursive table referenced or the subtree contains an immediate recursive call, the new table-reference is entailed the set of recursive table-references.

%Each CTE-scenario is augmented with its dependencies to previously defined CTEs. Each CTE is sliced into its different scenarios, then each scenario is analyzed, removed from the query and stored in the queue. When all CTEs are processed and the actual query is translated, only those CTEs are reattached to the query-scenario that are actually used. Indirect callsites can be detected by simply checking if there exists a free table-variable that is enlisted in $T$.

\subsection{Tracking CTE-dependencies}\label{tracking_cte_dependencies}
As has been shown, CTEs may use other CTEs directly or indirectly. Therefore we need to keep track of the dependencies of a scenario. This happens similar to the creation of the set $T$ of recursive CTEs. For each CTE \texttt{C} we collect all its CTE-references \texttt{$C_i$} from the scenario (predicate and query) together with their dependencies. For an illustration see \autoref{fig:cte_deps}.

\iffalse
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[x=10mm, y=15mm, node distance=1cm]
    \tikzset{Box/.style={shape=rectangle, draw, minimum width=1cm, minimum height=0.5cm, inner sep=2mm}}
    \node[anchor=west] at (-2.5, 1) {\WITH};
    
    \node[Box] (p0) at (0, 1)  {$p_0$};
    \node[Box, right of=p0] (q0) {$q_0$};
    \node at (3, 1) {$\emptyset$};
    \node at (5, 1) {$\emptyset$};
    
    \node[Box] (p1) at (0, 0)  {$p_1$};
    \node[Box, right of=p1] (q1) {$q_1$};
    \node at (3, 0) {$\{0\}$};
    \node at (5, 0) {$\emptyset$};
    
    \node[Box] (p2) at (0, -1)  {$p_2$};
    \node[Box, right of=p2] (q2) {$q_2$};
    \node at (3, -1) {$\emptyset$};
    \node at (5, -1) {$\{1\}$};
    
    \node[Box] (p3) at (0, -2)  {$p_3$};
    \node[Box, right of=p3] (q3) {$q_3$};
    \node at (3, -2) {$\{0, 1, 2\}$};
    \node at (5, -2) {$\emptyset$};
    
    \node[Box] (p4) at (0, -3)  {$p_4$};
    \node[Box, right of=p4] (q4) {$q_4$};
    \node at (3, -3) {$\emptyset$};
    \node at (5, -3) {$\emptyset$};
    
    \node[Box] (p5) at (0, -4)  {$p_5$};
    \node[Box, right of=p5] (q5) {$q_5$};
    \node at (3, -4) {$\{4\}$};
    \node at (5, -4) {$\{1, 4\}$};
    
    \node[Box, minimum width=2cm] (p) at (-1.5, -5){$p$};
    \node[Box, minimum width=2cm] (q) at (0.5, -5) {$q$};
    \node at (3, -5) {$\{0, 1, 2, 3\}$};
    \node at (5, -5) {$\{1, 4, 5\}$};
    
    \node[Box, minimum width=7cm] (r) at (-1.5, -6){\texttt{WITH $q_0, q_1, q_2, q_3, q_4$ SELECT $p \land p_0 \land p_1 \land p_2 \land p_3 \land p_4 \land p_5$}};
    \node[Box] at (5.37, -6) {\texttt{WITH $q_1, q_4, q_5$ SELECT $q$}};
    
    \draw[->] (p1.north) to (q0.south);
    \draw[->] (q2.north) to (q1.south);
    \draw[->] (p5.north) to (q4.south);
    \draw[->] (p3.north) to (q2.south);
    \draw[->, bend left=40, in=140] (p.north) to (q3.south);
    \draw[->] (p5.north) to (q4.south);
    \draw[->, bend right=15] (q5.north east) to (q1.south east);
    \draw[->] (q.north) to (q5.south);
    \draw[->] (q5.north) to (q4.south);
    \end{tikzpicture}
    \caption{References are tracked incrementally by collecting free table-variables (ie. direct CTE references) along with the references of those free table-variables. Note that the use of $\deps$ here varies from its definition to illustrate the process more clearly.}
    \label{fig:cte_deps}
\end{figure}
\fi

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[x=10mm, y=10mm]
    \node[anchor=west] at (-1, 0) {\WITH};
    \node[anchor=west] (A) at (0, 0)  {\texttt{A} \AS $(\ast a),$};
    \node[anchor=west] (B) at (0, -1) {\texttt{B} \AS $(b),$};
    \node[anchor=west] (C) at (0, -2) {\texttt{C} \AS $(c),$};
    \node[anchor=west] (D) at (0, -3) {\texttt{D} \AS $(d)$};
    \node[anchor=west] (Ar) at (3, 0)  {$\deps(a) = \FV(a) \cup \emptyset = \emptyset$};
    \node[anchor=west] (Br) at (3, -1) {$\deps(b) = \FV(b) \cup \emptyset = \emptyset$};
    \node[anchor=west] (Cr) at (3, -2) {$\deps(c) = \FV(c) \cup (\deps(a) \cup \deps(b)) = \{\texttt{B}, \texttt{A}\} \cup \emptyset$};
    \node[anchor=west] (Dr) at (3, -3) {$\deps(d) = \FV(d) \cup (\deps(c)) = \{\texttt{C}\} \cup \{\texttt{B}, \texttt{A}\}$};
    \draw[->, bend right=60] (C) to (A);
    \draw[->] (C) to (B);
    \draw[->] (D) to (C);
    \end{tikzpicture}
    \caption{References are tracked incrementally by collecting free table-variables (ie. direct CTE references) along with their dependencies. $a \rightarrow b$ means that $a$ contains a reference to $b$. Note that $\deps$ is simplified here to illustrate the process more clearly.}
    \label{fig:cte_deps}
\end{figure}

The actual implementation differs from the example shown in \autoref{fig:cte_deps}. Each CTE is removed from the query after it is analyzed. Therefore it is difficult to trace back references recursively. The ordering of CTEs enables us to perform this task incrementally creating a full list of dependencies for every individual CTE while analyzing:

$$\deps(C, q) := \FV(q) \cup \left(\bigcup_{(\_, \_, \_, ds) \in C[\FV(q)]} ds \right)$$

The function $\deps$ collects free table-variables (ie. used CTEs) of $q$ together with their dependencies $ds$. CTE-dependencies are retrieved from the CTE-store $C$ using the CTEs used by $q$. Because CTEs cannot make forward-references we obtain a full list of CTE-dependencies in this way.

%Different to tracking recursive CTEs, shadowing is not an issue here. The difference is that the list of recursive table-variables $T$ was passed down to further computation steps. Here, $C$ is only nonempty while processing CTEs of the same \texttt{WITH}-query where CTE-names are unique. Nested CTEs may shadow out outer CTEs indeed, but this issue is already solved by $\FV$.

\iffalse
\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
    \node (cte) at (4, 1) {\texttt{WITH C} \AS $\highlight[red!15]{c}~ \underbrace{\texttt{SELECT * FROM C}}_e$};
    \node (cte1) at (0, -1) {\footnotesize
        \begin{tabular}{|p{1em}|r|c|}\hline
        \cellcolor{gray!25} $\ast$ & $p_1$ & $\highlight[red!15]{c'_1}$\\\hline
        \end{tabular}
    };
    \node (cte2) at (8, -1) {\footnotesize
        \begin{tabular}{|p{1em}|r|c|}\hline
        \cellcolor{gray!25} & $p_2$ & $\highlight[red!15]{c'_2}$\\\hline
        \end{tabular}
    };
    \node (select1) at (0, -3) {\texttt{SELECT ... FROM C ...}};
    \node (select2) at (8, -3) {\texttt{SELECT ... FROM C ...}};
    \node (r1) at (0, -5) {\footnotesize
        \begin{tabular}{|p{1em}|r|c|}\hline
        \cellcolor{gray!25} $\ast$ & $p_1 \land \hdots$ & $\highlight[red!15]{\texttt{WITH C AS } ~\highlight[red!35]{c'_1}}~\highlight[green!15]{\SELECT~*~\texttt{FROM C}}$\\\hline
        \end{tabular}
    };
    \node (r2) at (8, -5) {\footnotesize
        \begin{tabular}{|p{1em}|r|c|}\hline
        \cellcolor{gray!25} & $p_2 \land \hdots$ & $\highlight[red!15]{\texttt{WITH C AS } ~\highlight[red!35]{c'_2}}~\highlight[green!15]{\SELECT~*~\texttt{FROM C}}$\\\hline
        \end{tabular}
    };
    \draw[->, double, out=270, in=90] (cte) to (cte1.north);
    \draw[->, double, out=270, in=90] (cte) to (cte2.north);
    \draw[->] (cte1.south) --node[left] {$T := T \cup \{\texttt{C}\}$} (select1);
    \draw[->] (cte2.south) --node[right]{$T := T \setminus \{\texttt{C}\}$} (select2);
    \draw[->] (select1) --node[left] {$FV \cap T \neq \emptyset$} (r1);
    \draw[->] (select2) --node[left] {$FV \cap T = \emptyset$} (r2);
    \end{tikzpicture}
    \caption{}
    \label{fig:my_label}
\end{figure}
\fi

\subsection{{\normalfont\RCTE}-rule: Collecting and analyzing CTE-Scenarios}

The idea from the \REXPR-rule of building the cross product between all scenarios of its subtrees is also present in the \RCTE-rule (\autoref{rule:cte}). Yet our extended notion of a function is not suitable for an entire \texttt{WITH}-clause. There is no \texttt{WITH}-"function" node at the root with $n$ independent children, one for each CTE: $\texttt{WITH}(t_1, t_2, t_3, q)$. It is more a right-deep tree of individual CTE-definitions where each CTE depends on the preceding CTEs: $\texttt{CTE}(t_1, \texttt{CTE}(t_2, \texttt{CTE}(t_3, q)))$. Therefore each \texttt{CTE} must be analyzed individually and the environment is modified accordingly for every CTE-scenario. With the changed environment following CTEs are analyzed and eventually the actual query $q$.

The environment is changed in two ways: First, the list of recursive table-variables $T$ is updated. If the evaluation-scenario of the CTE is recursive the alias of the CTE is added to $T$. If the CTE-scenario is nonrecursive the alias is removed from $T$ since any recursive reference is now shadowed by this nonrecursive CTE. Second, the CTE-scenario is added alongside its dependencies to the CTE-store $C$.

\begin{figure}[h!]
    \centering\footnotesize
\makebox[\textwidth][c]{
$$\inferrule{
    \hasCallsite(T, \WITH~ a_1 \AS t_1, ..., a_n \AS t_n~q)\\\\
    T, \varnothing \vdash (p, t_1) \rightarrow (B, R) \\
    \forall (p'_t, t') \in B: T \setminus \{a_1\}, C[a_1: (t', p'_t, \deps(C, t') \cup \deps(C, p'_t)] \vdash (p, \WITH~ a_2 \AS t_2, ..., a_n \AS t_n~q) \rightarrow (B_i, R_i) \\
    \forall (p'_t, t') \in R: T \cup      \{a_1\}, C[a_1: (t', p'_t, \deps(C, t') \cup \deps(C, p'_t)] \vdash (p, \WITH~ a_2 \AS t_2, ..., a_n \AS t_n~q) \rightarrow (B_j, R_j)
}{
{\begin{tabular}{L}
    T, C \vdash (p, \WITH~ a_1 \AS t_1, ..., a_n \AS t_n~q) \rightarrow \\
             \Big( \big(\cup_{1 \leq i \leq k} B_i\big) \cup \big(\cup_{1 \leq j \leq l} B_j\big),\phantom{\Big)}\\
    \phantom{\Big(}\big(\cup_{1 \leq j \leq k} R_j\big) \cup \big(\cup_{1 \leq j \leq l} R_j\big)\phantom{,}\Big)
\end{tabular}}
}\quad(\textsc{cte})$$
}
    \caption{\RCTE-rule}
    \label{rule:cte}
\end{figure}
% Discussion
%It may be possible to directly check whether the CTE will be referenced. This way the \RWITH-rule would be unnecessary and $C$ could be removed from the environment. The challange is to deconstruct the changed

\iffalse %oooold
$$\inferrule{
    \hasCallsite(T, \WITH a_1 \AS t_1, ..., a_n \AS t_n~q)\\
    T, \varnothing \vdash (p, t_1) \rightarrow (B, R) \\
    ((B \times \{\bot\}) \cup (R \times \{\top\})) = \{(p'_{t_1}, t'_1, r_{i_1}), ..., (p'_{t_k}, t'_k, r_k)\} = X\\
    \forall (p'_t, t', r_i) \in X: T[a_1 \mapsto r_i], C[a_1: (t', p'_t, \deps(t')] \vdash (p, \WITH a_2 \AS t_2, ..., a_n \AS t_n~q) \rightarrow (B_i, R_i)
}{
    T, C \vdash (p, \WITH a_1 \AS t_1, ..., a_n \AS t_n~q) \rightarrow ((\cup_{1 \leq i \leq k} B_i), (\cup_{1 \leq j \leq k} R_j)\})
}\quad(\textsc{cte})$$
\fi

\subsection{{\normalfont\RWITH}-rule: Attaching used CTEs only}
When all CTEs have been analyzed and moved the CTE-store $C$ the actual query is analyzed and required CTEs are reattached. This happens in three steps, nearly identical for recursive and nonrecursive scenarios of \texttt{q}. The only difference is the origin of the query scenario, once it is $B$ and once $R$.

For both, scenario-predicate and -query, dependent CTE-scenarios are retrieved from $C$. The CTE-queries are attached to query and predicate. Predicates of the CTEs $p_1, \dots, p_n$ are added alongside $p$ to the resulting predicate.

Note that we do not differentiate between CTEs referenced by the predicate only and CTEs referenced by the query only. As of now, all CTEs of the \textit{scenario} are added to the predicate and to the query. This could lead to unused CTEs for both the scenario-predicate as well as the scenario-query.

CTEs referenced by the predicate must be nonrecursive as scenario-predicates are always nonrecursive. Therefore any referenced CTE is also nonrecursive. This is important because otherwise $\hasCallsite$ would not work correctly. Still, a recursive CTE referenced by the scenario-query can be included unnecessarily in the scenario-predicate. Again, this is no problem as predicates are never examined by $\hasCallsite$ and unused CTEs are not evaluated.

Removing unsued CTEs from the scenario-predicate would clutter the inference rules while only improving aesthetics. We would need to track different dependencies of the scenario-predicate and -query. A scenario-predicate can use a CTE which again has a predicate that uses other CTEs. Dependencies of a scenario-predicate therefore involve all \textit{scenario-dependencies} (dependencies of predicate and query) while the dependencies of the scenario-query require only to mind query to query references.

%1) The actual query is analyzed, resulting in nonrecursive scenarios $B$ resp. $R$. 2) For the given scenario, the CTEs referenced by the query $q'$ are looked up from ($C[\deps_q(q')]$) and prepended to the resulting scenario-query. 3) All CTEs, referenced either by scenario-queries or scenario-predicates, are retrieved ($C[\deps_q(q') \cup \deps_p(p')]$) and their predicates ($p_1, ..., p_k$) are added to the resulting scenario-predicate. 4) As each predicate may include again references to CTEs, these references $dp_1, \dots,  dp_k$ are used to retrieve the CTE required to evaluate the scenario-predicate ($C[dp_1 \cup \dots \cup dp_k]$).

\begin{figure}[h!]
    \centering\small
\makebox[\textwidth][c]{$$\inferrule{
    C \neq \varnothing\\
    T, \varnothing \vdash (p, q) \rightarrow (B, R)
}{
    T, C \vdash (p, \WITH~ q) \rightarrow \\\\
    {\begin{tabular}[b]{LLLL}
    \Big(~~&\big\{&(&\WITH~ a_1 \AS t_1, \dots, a_n \AS t_n~\SELECT~ p_q ~\AND~p_1 ~\AND~ \dots ~\AND~ p_n, \\
          &&&\WITH~ a_1 \AS t_1, \dots, a_n \AS t_n~~q'~\\
          &&| &~(p_q, q') \in B, C[\deps(C, q') \cup \deps(C, p')] = \langle (a_1, t_1, p_1, \_), \dots, (a_n, t_n, p_n, \_) \rangle \big\}\\[3mm]
           &\big\{&(&\WITH~ a_1 \AS t_1, \dots, a_n \AS t_n~\SELECT~ p_q ~\AND~p_1 ~\AND~ \dots ~\AND~ p_n, \\
          &&&\WITH~ a_1 \AS t_1, \dots, a_n \AS t_n~~q'~\\
          &&| &~(p_q, q') \in R, C[\deps(C, q') \cup \deps(C, p')] = \langle (a_1, t_1, p_1, \_), \dots, (a_n, t_n, p_n, \_) \rangle \big\}\Big)\\
    \end{tabular}}
}\quad(\textsc{with})$$}
    \caption{\RWITH-rule}
    \label{rule:with}
\end{figure}

\iffalse both versions combined
\makebox[\textwidth][c]{$$\inferrule{
    C \neq \varnothing\\
    T, \varnothing \vdash (p, q) \rightarrow (B, R)
}{
    T, C \vdash (p, \WITH~ q) \rightarrow \\\\
    {\begin{tabular}[b]{LLLL}
    \Big(~~&\big\{&(&\WITH~ a_1 \AS t_1, \dots, a_n \AS t_n~\SELECT~ p_q ~\AND~p_1 ~\AND~ \dots ~\AND~ p_n, \\
          &&&\WITH~ a_1 \AS t_1, \dots, a_n \AS t_n~~q'~\\
          &&| &~(p_q, q') \in B, C[\deps(C, q') \cup \deps(C, p')] = \langle (a_1, t_1, p_1, \_), \dots, (a_n, t_n, p_n, \_) \rangle \big\}\\[3mm]
    &\big\{&(&\WITH~ a_1 \AS t_1, \dots, a_m \AS t_m~\SELECT~ p_q ~\AND~p_1 ~\AND~ \dots ~\AND~ p_k, \\
          &&&\WITH~ a_1 \AS t_1, \dots, a_n \AS t_n~~q'~\\
          &&| &~(p_q, q') \in R,\\
          &&  &~C[\deps_q(C, q')] ~~~~~~~~~~~~~~~~~= \langle (a_1, t_1, \_, \_, \_), \dots, (a_n, t_n, \_, \_, \_) \rangle,\\
          &&  &~C[\deps_p(C, p') \cup \deps_p(C, q')] = \langle (a_1, t_1, \_, \_, \_), \dots, (a_m, t_m, \_, \_, \_) \rangle,\\
          &&  &~C[\deps_p(C, p') \cup \deps_q(C, q')] = \langle (\_, \_, p_1, \_, \_), \dots, (\_, \_, p_k, \_, \_) \rangle \big\}\Big)\\
    \end{tabular}}
}\quad(\textsc{with})$$}
\fi

\iffalse old
\makebox[\textwidth][c]{$$\inferrule{
    C \neq \varnothing\\
    T, \varnothing \vdash (p, q) \rightarrow (B, R)
}{
    T, C \vdash (p, \WITH~ q) \rightarrow \\\\
    {\begin{tabular}[b]{LLLL}
    \Big(~~&\{&(&\WITH~ [a_i \AS t_i]^{(a_i, t_i) \in \sigma_{a, t}(P_{ctes})}~\SELECT~ (\AND_{p_i \in P}(p_i)), \\
          &&&\WITH~ [a_i \AS t_i]^{(a_i, t_i) \in \sigma_{a, t}(q'_{ctes})}~~q'~\\
          &&| &~(p_q, q') \in B,~ q'_{ctes} = C[\deps(q')],~P=\{p_q\} \cup \sigma_p(q'_{ctes}),~ P_{ctes} = C[\cup_{x_p \in P} \deps(x_p)]\},\\
    &\{&(&\WITH~ [a_i \AS t_i]^{(a_i, t_i) \in \sigma_{a, t}(P_{ctes})}~\SELECT~ (\AND_{p_i \in P}(p_i)), \\
    &&&\WITH~ [a_i \AS t_i]^{(a_i, t_i) \in \sigma_{a, t}(q'_{ctes})}~~q'~\\
    &&|&~(p_q, q') \in R,~ q'_{ctes} = C[\deps(q')],~P=\{p_q\} \cup \sigma_p(q'_{ctes}),~ P_{ctes} = C[\cup_{x_p \in P} \deps(x_p)])\Big)
    \end{tabular}}
}\quad(\textsc{with})$$}
\\
\fi

\section{Extraction of callsite-arguments}

The callgraph-template requires the callsite-arguments as standalone queries for each scenario. Without CTEs they can be directly cut from the callsite because we do not allow any outside row-references. However, with CTEs callsite arguments may contain a query referencing CTEs. Therefore we must keep those CTEs from each query-level that are (directly or indirectly) used by the callsite-argument.

I have formulated inference rules to perform this extraction. From a query-fragment $q$ a set of tuples $(e_1, e_2, \dots, e_n)$ is derived. Each component $e_i$ of a tuple is a stand-alone version of a callsite-argument. The only environment is the CTE-store $C$ required to detach and reattach the CTEs analogious to the scenario analysis.

When extracting callsite-arguments, referenced callsites are of no interest. It is just required to tell if a subtree directly contains a callsite whose arguments need to be extracted. Therefore the simple notion of containing a callsite, known from the beginning of the chapter, can be used.

$$\text{containsCallsite}_fn(e_i) = fn \sqsubset e$$

The rules for argument extraction are rather simple thanks to the constraint that no row-references are allowed inside callsite arguments. Extracting a subexpression with row-references from a query would require more sophisticated rules.

This way each rule basically just unwraps each layer of the query while special care is taken for CTEs. The two axioms result either in an empty set if no callsite is contained in the subtree (\textsc{nocall}-rule) or adds the arguments to the result set (\textsc{call}-rule).

\begin{equation*}
    \inferrule{
}{
    \varnothing \vdash fn_{rec}(e_1, e_2, ..., e_n) \rightarrow \{ (e_1, e_2, ..., e_n) \}
}\quad(\footnotesize\textsc{call})
\end{equation*}
\\
\begin{equation*}
\inferrule{
    \neg \text{containsCallsite}_{fn}(e)
}{  
    \varnothing \vdash e \rightarrow \{\}
}\quad(\footnotesize\textsc{nocall})
\end{equation*}

Expressions, functions etc. can simply be traversed collecting results from each subtree (\textsc{remove expr}-rule). The definition of "functions" $\oplus$ is the same as for the \REXPR-rule.

\begin{equation*}
    \inferrule{
    \exists i \in \{1, ...., n\}: \text{containsCallsite}_{fn}(e_i)\\
    \forall i \in \{1, ...., n\}: \varnothing \vdash e_i \rightarrow E
}{
    \varnothing \vdash \oplus_{1 \leq i \leq n} e_i \rightarrow \cup_{i \in \{1, ...., n\}} E_i
}\quad(\footnotesize\textsc{remove expr})
\end{equation*}

The \textsc{remove select}-rule traverses each element of the select-list if the callsite(s) are located within the select-clause. The from- and where-clauses are discarded as the value of the callsite-arguments must be uncorrelated with row-references declared in any outer \FROM.

\begin{equation*}
\inferrule{
    \exists i \in \{1, ..., n\}: \text{containsCallsite}_{fn}(s_i) \\
    \forall i \in \{1, ..., n\}: \varnothing \vdash s_i \rightarrow E_i
}{
    \varnothing \vdash \SELECT ~s_1, ..., s_n ~\FROM~ f ~\WHERE~ w \rightarrow \\\\
    \{\big(\SELECT~ e_1, ..., \SELECT ~e_k\big) ~|~ (e_1, ..., e_k) \in \cup_{i \in \{1, ..., n\}} E_1 \}
}\quad(\footnotesize\textsc{remove select})
\end{equation*}

The surrounding query can be removed if the callsites are located within the from-clause (\textsc{remove from}-rule).

\begin{equation*}
\inferrule{
    \exists i \in \{1, ..., n\}: \text{containsCallsite}_{fn}(s_i) \\
    \forall i \in \{1, ..., n\}: \varnothing \vdash t_i \rightarrow E_i
}{
    \varnothing \vdash \SELECT~s~\FROM~t_1, t_2, \dots, t_n~\WHERE~ w \rightarrow \\\\
    \cup_{i \in \{1, ..., n\}} E_i
}\quad(\footnotesize\textsc{remove from})
\end{equation*}

Yet not directly required for correct evaluation, unused CTEs are removed. Each CTE is temporarily moved to the CTE-store together with information about its dependencies, similar to the \RCTE-rule. Note that callsites can also occur directly in CTEs.

\begin{equation*}
\inferrule{
    \varnothing \vdash t_1 \rightarrow E \\\\
    C[a_1 : (t_1, \deps(C, t_1))] \vdash \WITH~ a_2 \AS t_2, ..., a_n \AS t_n ~q \rightarrow E_w
}{
    C \vdash \WITH~ a_1 \AS t_1, ..., a_n \AS t_n ~q \rightarrow \\\\
    E_w \cup E
}\quad(\footnotesize\textsc{remove cte})
\end{equation*}

When all CTE-dependencies have been collected those CTEs which are referenced by a callsite-argument are reattached.

\begin{equation*}
\small
\inferrule{
    \varnothing \vdash q \rightarrow E
}{
    C \vdash \WITH~ q \rightarrow \\\\
    {\begin{tabular}[b]{L}
    \big\{\big(\WITH~ [a_i \AS t_i]_{(a_i, t_i, \_) \in C[\deps(e)]} ~e_1, 
       ~\dots~,
       \WITH~ [a_i \AS t_i]_{(a_i, t_i, \_) \in C[\deps(e_m)]} ~e_m\big)\\
       \phantom{\big\{}|~(e_1, ..., e_m) \in E\big\}
   \end{tabular}}
}\quad(\footnotesize\textsc{remove with})
\end{equation*}

